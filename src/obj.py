"""Private library for app objects.

Game objects inherit Pydantic's BaseModel class to imbue them with
some useful helper fuctions, re: FastAPI.

"""
from typing import Any, Dict, Optional, Tuple

from pydantic import BaseModel


class BaseRequest(BaseModel):
    """Abstract container for an API request."""

    id: int
    request: str


class Flake(BaseModel):
    """Quote-unquote "imprint" class.

    Provides BaseModel to game objects, allowing transfer over FastAPI.
    """

    ...


class User(Flake):
    """An object with basic user information.

    Attributes:
        id (int): Unique ID for object
        name (str): The user's display name

    """

    id: int
    username: str


class Move(Flake):
    """An object containing information about the move and the user

    Attributes:
        parent_command_id (int): UID of the `Command` that initiated a `GetMoveCommand`
        move (str): either "rock", "paper", or "scissors"
        user (User): the `User` submitting the move

    """

    parent_uid: int
    move: str
    # user: User


class State(Flake):
    """Base implementation of a State"""

    name: str


class States(Flake):
    """A simple dataclass for State definitions"""

    welcome: State = State(name="Welcome")
    req_lobby: State = State(name="Requesting Lobby")
    in_lobby: State = State(name="In Lobby")
    match_request: State = State(name="Requesting Match")
    matched: State = State(name="Matched")
    rejected: State = State(name="Rejected")
    ready: State = State(name="Players Ready?")
    get_move: State = State(name="Submit Moves")
    game_over: State = State(name="Game Over")


class GameState(Flake):
    """A complete game state class, indicating the involved users, current game data,
    current game status (pending moves, pending game start, etc), and any other
    information needed to process or rebuild the game's current state, across modules.

    NOTE: See `States` class for complete list of states

    """

    game_id: Optional[int] = None
    state: State = States().welcome
    players: Optional[Tuple[User]] = None
    ready: Optional[Tuple[User]] = None
    current_moves: Optional[Dict[str, Move]] = None
    moves_history: Optional[Tuple[Tuple[Any, Move]]] = None
    winner: Optional[Any] = None

    class Config:
        arbitrary_types_allowed = True


class Command(Flake):
    """An instruction packet, generated by Server, consumed by Client.

    Contains instructions that trigger state changes in the UI.
    Should always be subclassed, with more specific information made available
    for each type of Command (display_game_over, await_response, )

    Attributes:
        id (int): Unique ID for object


    Functions:
        execute()
            * contains the functions necessary to trigger change in the client

    """

    uid: int
    command: str
    state: GameState


class Mocks:
    users = {
        "user1": {"id": "51", "username": "one o' ya"},
        "user2": {"id": "420", "username": "another 'ya"},
        "me": {"id": 7734, "username": "cbxm"},
    }

    states = {
        "welcome": {
            "game_id": 0,
            "state": States().welcome,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "req_lobby": {
            "game_id": 1,
            "state": States().req_lobby,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "in_lobby": {
            "game_id": 2,
            "state": States().in_lobby,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "match_request": {
            "game_id": 3,
            "state": States().match_request,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "matched": {
            "game_id": 4,
            "state": States().matched,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "rejected": {
            "game_id": 5,
            "state": States().rejected,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "ready": {
            "game_id": 6,
            "state": States().ready,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "get_move": {
            "game_id": 7,
            "state": States().get_move,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
        "game_over": {
            "game_id": 8,
            "state": States().game_over,
            "players": None,
            "ready": None,
            "current_moves": None,
            "moves_history": None,
            "winner": None,
        },
    }

    @staticmethod
    def make_gs(name: str = "welcome") -> GameState:
        return GameState(**Mocks.states[name])

    @staticmethod
    def make_user(name: str = "me") -> User:
        return User(**Mocks.states[name])
